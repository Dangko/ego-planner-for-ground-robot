#include "path_searching/dyn_a_star.h"

using namespace std;
using namespace Eigen;

AStar::~AStar()
{
    for (int i = 0; i < POOL_SIZE_(0); i++)
        for (int j = 0; j < POOL_SIZE_(1); j++)
                delete GridNodeMap_[i][j];
}

void AStar::initGridMap(GridMap::Ptr occ_map, const Eigen::Vector2i pool_size)
{
    POOL_SIZE_ = pool_size;
    CENTER_IDX_ = pool_size / 2;

    GridNodeMap_ = new GridNodePtr *[POOL_SIZE_(0)];
    for (int i = 0; i < POOL_SIZE_(0); i++)
    {
        GridNodeMap_[i] = new GridNodePtr [POOL_SIZE_(1)];
        for (int j = 0; j < POOL_SIZE_(1); j++)
        {
            GridNodeMap_[i][j] = new GridNode;
        }
    }

    grid_map_ = occ_map;
}

//double AStar::getDiagHeu(GridNodePtr node1, GridNodePtr node2)
//{
//    double dx = abs(node1->index(0) - node2->index(0));
//    double dy = abs(node1->index(1) - node2->index(1));
//    double dz = abs(node1->index(2) - node2->index(2));
//    double w_constrain_z = 1000.0;
//
//    double h = 0.0;
//    int diag = min(min(dx, dy), dz);
//    dx -= diag;
//    dy -= diag;
//    dz -= diag;
//
//    if (dx == 0)
//    {
//        h = 1.0 * sqrt(3.0) * diag + sqrt(2.0) * min(dy, dz) + 1.0 * abs(dy - dz);
//    }
//    if (dy == 0)
//    {
//        h = 1.0 * sqrt(3.0) * diag + sqrt(2.0) * min(dx, dz) + 1.0 * abs(dx - dz);
//    }
//    if (dz == 0)
//    {
//        h = 1.0 * sqrt(3.0) * diag + sqrt(2.0) * min(dx, dy) + 1.0 * abs(dx - dy);
//    }
//
//    //for ground robot,need to constrain score at axis z
//    return h;
//}

double AStar::getDiagHeu(GridNodePtr node1, GridNodePtr node2)
{
    double dx = abs(node1->index(0) - node2->index(0));
    double dy = abs(node1->index(1) - node2->index(1));


    double h = 0.0;
    int diag = min(dx, dy);
    dx -= diag;
    dy -= diag;

    if (dx == 0)
    {
        h = 1.0 * sqrt(2.0) * diag + 1.0 * abs(dy);
    }
    if (dy == 0)
    {
        h = 1.0 * sqrt(2.0) * diag +  + 1.0 * abs(dx);
    }


    //for ground robot,need to constrain score at axis z
    return h;
}

double AStar::getManhHeu(GridNodePtr node1, GridNodePtr node2)
{
    double dx = abs(node1->index(0) - node2->index(0));
    double dy = abs(node1->index(1) - node2->index(1));

    return dx + dy ;
}

double AStar::getEuclHeu(GridNodePtr node1, GridNodePtr node2)
{
    return (node2->index - node1->index).norm();
}

vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)
{
    vector<GridNodePtr> path;
    path.push_back(current);

    while (current->cameFrom != NULL)
    {
        current = current->cameFrom;
        path.push_back(current);
    }

    return path;
}

bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector2d start_pt, Vector2d end_pt, Vector2i &start_idx, Vector2i &end_idx)
{
    if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))
        return false;

    if (checkOccupancy(Index2Coord(start_idx)))
    {
        //ROS_WARN("Start point is insdide an obstacle.");
        do
        {
            start_pt = (start_pt - end_pt).normalized() * step_size_ + start_pt;
            if (!Coord2Index(start_pt, start_idx))
                return false;
        } while (checkOccupancy(Index2Coord(start_idx)));
    }

    if (checkOccupancy(Index2Coord(end_idx)))
    {
        //ROS_WARN("End point is insdide an obstacle.");
        do
        {
            end_pt = (end_pt - start_pt).normalized() * step_size_ + end_pt;
            if (!Coord2Index(end_pt, end_idx))
                return false;
        } while (checkOccupancy(Index2Coord(end_idx)));
    }

    return true;
}

bool AStar::ConvertToIndexAndAdjustStartEndPointsReverse(Eigen::Vector2d start_pt, Eigen::Vector2d end_pt,Eigen::Vector2i &start_idx, Eigen::Vector2i &end_idx) {
    if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))
        return false;

    if (checkOccupancy(Index2Coord(start_idx)))
    {
        //ROS_WARN("Start point is insdide an obstacle.");
        do
        {
            start_pt = (end_pt - start_pt).normalized() * step_size_ + start_pt;
            if (!Coord2Index(start_pt, start_idx))
                return false;
        } while (checkOccupancy(Index2Coord(start_idx)));
    }

    if (checkOccupancy(Index2Coord(end_idx)))
    {
        //ROS_WARN("End point is insdide an obstacle.");
        do
        {
            end_pt = (start_pt - end_pt).normalized() * step_size_ + end_pt;
            if (!Coord2Index(end_pt, end_idx))
                return false;
        } while (checkOccupancy(Index2Coord(end_idx)));
    }

    return true;
}

//bool AStar::AstarSearch(const double step_size, Vector2d start_pt, Vector2d end_pt)
//{
//    ros::Time time_1 = ros::Time::now();
//    ++rounds_;
//
//    step_size_ = step_size;
//    inv_step_size_ = 1 / step_size;
//    center_ = (start_pt + end_pt) / 2;
//
//    Vector2i start_idx, end_idx;
//    if (!ConvertToIndexAndAdjustStartEndPoints(start_pt, end_pt, start_idx, end_idx))
//    {
//        ROS_ERROR("Unable to handle the initial or end point, force return!");
//        return false;
//    }
//
//    // if ( start_pt(0) > -1 && start_pt(0) < 0 )
//    //     cout << "start_pt=" << start_pt.transpose() << " end_pt=" << end_pt.transpose() << endl;
//
//    GridNodePtr startPtr = GridNodeMap_[start_idx(0)][start_idx(1)][start_idx(2)];
//    GridNodePtr endPtr = GridNodeMap_[end_idx(0)][end_idx(1)][end_idx(2)];
//
//    std::priority_queue<GridNodePtr, std::vector<GridNodePtr>, NodeComparator> empty;
//    openSet_.swap(empty);
//
//    GridNodePtr neighborPtr = NULL;
//    GridNodePtr current = NULL;
//
//    startPtr->index = start_idx;
//    startPtr->rounds = rounds_;
//    startPtr->gScore = 0;
//    startPtr->fScore = getHeu(startPtr, endPtr);
//    startPtr->state = GridNode::OPENSET; //put start node in open set
//    startPtr->cameFrom = NULL;
//    openSet_.push(startPtr); //put start in open set
//
//    endPtr->index = end_idx;
//
//    double tentative_gScore;
//
//    int num_iter = 0;
//    while (!openSet_.empty())
//    {
//        num_iter++;
//        current = openSet_.top();
//        openSet_.pop();
//
//        // if ( num_iter < 10000 )
//        //     cout << "current=" << current->index.transpose() << endl;
//
//        if (current->index(0) == endPtr->index(0) && current->index(1) == endPtr->index(1) && current->index(2) == endPtr->index(2))
//        {
//            // ros::Time time_2 = ros::Time::now();
//            // printf("\033[34mA star iter:%d, time:%.3f\033[0m\n",num_iter, (time_2 - time_1).toSec()*1000);
//            // if((time_2 - time_1).toSec() > 0.1)
//            //     ROS_WARN("Time consume in A star path finding is %f", (time_2 - time_1).toSec() );
//            gridPath_ = retrievePath(current);
//            return true;
//        }
//        current->state = GridNode::CLOSEDSET; //move current node from open set to closed set.
//
//        for (int dx = -1; dx <= 1; dx++)
//            for (int dy = -1; dy <= 1; dy++)
//                for (int dz = -1; dz <= 1; dz++)
//                {
//                    if (dx == 0 && dy == 0 && dz == 0)
//                        continue;
//
//                    Vector2i neighborIdx;
//                    neighborIdx(0) = (current->index)(0) + dx;
//                    neighborIdx(1) = (current->index)(1) + dy;
//                    neighborIdx(2) = (current->index)(2) + dz;
//
//                    if (neighborIdx(0) < 1 || neighborIdx(0) >= POOL_SIZE_(0) - 1 || neighborIdx(1) < 1 || neighborIdx(1) >= POOL_SIZE_(1) - 1 || neighborIdx(2) < 1 || neighborIdx(2) >= POOL_SIZE_(2) - 1)
//                    {
//                        continue;
//                    }
//
//                    neighborPtr = GridNodeMap_[neighborIdx(0)][neighborIdx(1)][neighborIdx(2)];
//                    neighborPtr->index = neighborIdx;
//
//                    bool flag_explored = neighborPtr->rounds == rounds_;
//
//                    if (flag_explored && neighborPtr->state == GridNode::CLOSEDSET)
//                    {
//                        continue; //in closed set.
//                    }
//
//                    neighborPtr->rounds = rounds_;
//
//                    if (checkOccupancy(Index2Coord(neighborPtr->index)))
//                    {
//                        continue;
//                    }
//
//                    double static_cost = sqrt(dx * dx + dy * dy + dz * dz);
//                    tentative_gScore = current->gScore + static_cost;
//
//                    if (!flag_explored)
//                    {
//                        //discover a new node
//                        neighborPtr->state = GridNode::OPENSET;
//                        neighborPtr->cameFrom = current;
//                        neighborPtr->gScore = tentative_gScore;
//                        neighborPtr->fScore = tentative_gScore + getHeu(neighborPtr, endPtr);
//                        openSet_.push(neighborPtr); //put neighbor in open set and record it.
//                    }
//                    else if (tentative_gScore < neighborPtr->gScore)
//                    { //in open set and need update
//                        neighborPtr->cameFrom = current;
//                        neighborPtr->gScore = tentative_gScore;
//                        neighborPtr->fScore = tentative_gScore + getHeu(neighborPtr, endPtr);
//                    }
//                }
//        ros::Time time_2 = ros::Time::now();
//        if ((time_2 - time_1).toSec() > 0.2)
//        {
//            ROS_WARN("Failed in A star path searching !!! 0.2 seconds time limit exceeded.");
//            return false;
//        }
//    }
//
//    ros::Time time_2 = ros::Time::now();
//
//    if ((time_2 - time_1).toSec() > 0.1)
//        ROS_WARN("Time consume in A star path finding is %.3fs, iter=%d", (time_2 - time_1).toSec(), num_iter);
//
//    return false;
//}

bool AStar::AstarSearch(const double step_size, Vector2d start_pt, Vector2d end_pt,bool is_adjust)
{
    ros::Time time_1 = ros::Time::now();
    ++rounds_;

    step_size_ = step_size;
    inv_step_size_ = 1 / step_size;
    center_ = (start_pt + end_pt) / 2;

    Vector2i start_idx, end_idx;
    Coord2Index(start_pt, start_idx);
    Coord2Index(end_pt, end_idx);
    Eigen::Vector3i local_bound_min,local_bound_max;
    grid_map_->getUpdatedBox(local_bound_min,local_bound_max);

    if(is_adjust)
    {
        if (!ConvertToIndexAndAdjustStartEndPoints(start_pt, end_pt, start_idx, end_idx))
        {
            ROS_ERROR("Unable to handle the initial or end point, force return!");
            return false;
        }
    }
    else
    {
        if (!ConvertToIndexAndAdjustStartEndPointsReverse(start_pt, end_pt, start_idx, end_idx))
        {
            ROS_ERROR("Unable to handle the initial or end point, force return!");
            return false;
        }
    }

    // if ( start_pt(0) > -1 && start_pt(0) < 0 )
    //     cout << "start_pt=" << start_pt.transpose() << " end_pt=" << end_pt.transpose() << endl;

    GridNodePtr startPtr = GridNodeMap_[start_idx(0)][start_idx(1)];
    GridNodePtr endPtr = GridNodeMap_[end_idx(0)][end_idx(1)];

    std::priority_queue<GridNodePtr, std::vector<GridNodePtr>, NodeComparator> empty;
    openSet_.swap(empty);

    GridNodePtr neighborPtr = NULL;
    GridNodePtr current = NULL;

    startPtr->index = start_idx;
    startPtr->rounds = rounds_;
    startPtr->gScore = 0;
    startPtr->fScore = getHeu(startPtr, endPtr);
    startPtr->state = GridNode::OPENSET; //put start node in open set
    startPtr->cameFrom = NULL;
    openSet_.push(startPtr); //put start in open set

    endPtr->index = end_idx;

    double tentative_gScore;
    int count_round=0;
    int num_iter = 0;
    while (!openSet_.empty())
    {
//        count_round+=1;
//        if(count_round%100==0)
//        {
//            ROS_INFO("A star searching ....");
//        }
        num_iter++;
        current = openSet_.top();
        openSet_.pop();

        // if ( num_iter < 10000 )
        //     cout << "current=" << current->index.transpose() << endl;

        if (current->index(0) == endPtr->index(0) && current->index(1) == endPtr->index(1))
        {
            // ros::Time time_2 = ros::Time::now();
            // printf("\033[34mA star iter:%d, time:%.3f\033[0m\n",num_iter, (time_2 - time_1).toSec()*1000);
            // if((time_2 - time_1).toSec() > 0.1)
            //     ROS_WARN("Time consume in A star path finding is %f", (time_2 - time_1).toSec() );
            gridPath_ = retrievePath(current);
            return true;
        }
        current->state = GridNode::CLOSEDSET; //move current node from open set to closed set.

        for (int dx = -1; dx <= 1; dx++)
            for (int dy = -1; dy <= 1; dy++)
                {
                    if (dx == 0 && dy == 0 )
                        continue;

                    Vector2i neighborIdx;
                    neighborIdx(0) = (current->index)(0) + dx;
                    neighborIdx(1) = (current->index)(1) + dy;

                    if (neighborIdx(0) < 1 || neighborIdx(0) >= POOL_SIZE_(0) - 1 || neighborIdx(1) < 1 || neighborIdx(1) >= POOL_SIZE_(1) - 1 )
                    {
                        continue;
                    }

                    neighborPtr = GridNodeMap_[neighborIdx(0)][neighborIdx(1)];
                    neighborPtr->index = neighborIdx;

                    bool flag_explored = neighborPtr->rounds == rounds_;

                    if (flag_explored && neighborPtr->state == GridNode::CLOSEDSET)
                    {
                        continue; //in closed set.
                    }

                    neighborPtr->rounds = rounds_;

                    if (checkOccupancy(Index2Coord(neighborPtr->index)))
                    {
                        continue;
                    }

                    double static_cost = sqrt(dx * dx + dy * dy );
                    tentative_gScore = current->gScore + static_cost;

                    if (!flag_explored)
                    {
                        //discover a new node
                        neighborPtr->state = GridNode::OPENSET;
                        neighborPtr->cameFrom = current;
                        neighborPtr->gScore = tentative_gScore;
                        neighborPtr->fScore = tentative_gScore + getHeu(neighborPtr, endPtr);
                        openSet_.push(neighborPtr); //put neighbor in open set and record it.
                    }
                    else if (tentative_gScore < neighborPtr->gScore)
                    { //in open set and need update
                        neighborPtr->cameFrom = current;
                        neighborPtr->gScore = tentative_gScore;
                        neighborPtr->fScore = tentative_gScore + getHeu(neighborPtr, endPtr);
                    }
                }
        ros::Time time_2 = ros::Time::now();
        if ((time_2 - time_1).toSec() > 0.05)
        {
            ROS_WARN("Failed in A star path searching !!! 0.2 seconds time limit exceeded.");
            return false;
        }
    }
    //ROS_WARN("Failed in A star path searching !!! No path found.");
    ros::Time time_2 = ros::Time::now();

    if ((time_2 - time_1).toSec() > 0.1)
        ROS_WARN("Time consume in A star path finding is %.3fs, iter=%d", (time_2 - time_1).toSec(), num_iter);

    return false;
}

vector<Vector3d> AStar::getPath()
{
    vector<Vector3d> path;
    Eigen::Vector3d pos;
    Eigen::Vector2d pos2d;
    for (auto ptr : gridPath_)
    {
        pos2d = Index2Coord(ptr->index);
        pos<<pos2d(0),pos2d(1),0,
        path.push_back(pos);
    }
    reverse(path.begin(), path.end());
    return path;
}

//vector<Vector2d> AStar::getPath()
//{
//    vector<Vector2d> path;
//
//    for (auto ptr : gridPath_)
//        path.push_back(Index2Coord(ptr->index));
//
//    reverse(path.begin(), path.end());
//    return path;
//}
